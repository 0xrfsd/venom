/*
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mMMMMMMMMMNNNmmNNNMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNMMMMNNNNNmmmddhdddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mddNMMNy:/odNmmddmmNNmdhhddmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmdNMNd:--+dNmmddhhddmmhsyhhmdmmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNmdNmy:.-oyNmmmhmdhho+sososyhhhddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmNdh+-`.:oyNNdmmdmmdo-://oysssyhhhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nmmmoyyyo+osdNmdmmddNNhs+/::/+osyssydyhdNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNmhsymMMNmmmmdmdNNddNmsso+++////ossssyyhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mhhhmNNMNNNhssshhmmddmmssyooooso/::+oysshhhhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmdhdddNNdyoosyhdmddmmmsoooooyysyys/::/oyyhhhyMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdddhddmhsooshdmdmdhhyyyysso/ooo+syhhs/-/+shyhMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dyyhdmd+ososhdmdmyyhhhhhhhyo++o/+///+ohhso++sdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dhdmNNdsossyhmdmsydhssssyhhs/++o/o+//:++yhhy+/hNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdmNNNNmhysshddyshdyyy/oss+s::/:://++///++++/::hmNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNMNNNmmNNdymNNhshdshdyhdysh+sy+-:++osssosss++yNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNNNmdNNmNmmmNmyyddyyhdhydyohys/-oo+osssysyyohNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNhdNmmNNmNMMNhyyhhhdhyyhmmyh+-/s+sysssyyhyydNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mNMMMhdNdmMNMMMMMNNmdhdddmhdmmNho/-osoyyo++oyddhhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NMMMNmhNdNMNMNMMNmNNNmmmdyoohmhoyo::hsooo++oooydhymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNhmNNMmmNMNNmmmmdmmdyhhoyddddoo++yoyysooossyhsmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNmmNNNmdNdNmmddhhhdNNhsmNssdooo/dso++osyyysoymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMNNNNmNNNNNmddmmNhshNmmmNmNMdhNsh/ohho++/:++MMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MNNNMMNNNNmmmhhhhdyosdNmdmMMhoNmhdmys+ooo++/+MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNMMNNNNmddmdoodmMMNmmNNhssdmNMMMNdNd/osomMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNdhMNmNNMNmdNddohmMMNNNmdmdddNMMMMMMMMmMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNhmMmmmmNNmdNyoNMNmNmdhyyyhdhoyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdmMmmddddNmmdys+hmMMMmmhysssyy++dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdNMMdmdddmmNNyshmNNNNNNNdhhs+yy//dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMMdmdddmmMNysdmNNMMMNhhNdhs+y+/:mMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNhmmddNNNMdyydmMMMNdyshNhyoss+:/MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMddmmmmNMNMNdsymNNmdhhdNMNdhsss+:yMMMMMMMMMMMMMMMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMdhmmmmmNMNNMmshNMMMmmMMMMMmNdyo+//NMMMMMMMMMMMMMMMhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMmhmmmmmmNMMNNMyshdhhhyhNMMMMMMdhso+sMMMMMMMMMMMMMMMhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMmdmmmmmmmNMMMmNm+ys++oyyNMMMMMMNmmyyoyNMMMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmmmmmmmmmmNMNNmNNyyo+/oohNMMMMMMMMdhhsshmMMMMMMMMMMMyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNNNNmmmmNMMNmmddNmmdhhdmMMMMMMMMMNddhssshmmNNNmmdhdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNNNNNNNNNNNNNNNmNNNNMMMMMNomMMMMMMMMMNNmdhhyyyyyyyhdmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nd+oNMMMMMMMmodo++++++++++m..yNMMMMMNo+mNMMmhssshdNMMNhNMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MN+ /NMMMMMm: d` -ssssss+`d. `+mMMMMN. dNm+:+syso//hNN--yNMMMMMMMd+`yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMN+ /NMMMm: oM` +NMMMMMNdN. /`.yNMMN. dh.omMMMMMNy.oM- `:hNMMMm+.  yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMN/ /NMm: oNy` :sssmMMMMN. dh-`/mMN. d-/NMMMMMMMMy`m- y/`/dmo..o: yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMN/ /m: +NNy. /yyyNMMMMN. dNNo`.yN- d.oNMMMMMMMMd d- mNh-`.`+mN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMN/ . +NMMN- oNMMMMMNdN. dMMMd:`/. ds.dNMMMMMMm::M- dMMNy/dMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMN/ +NMMMN- /yyyyyys d. dMMMMNo`  dNy-+ymmmho-+NN- dMMMMMMMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMNyNMMMMN+::::::::::m+/mMMMMMMd: dMMNho///+ymMMN+/mMMMMMMMMNs/hMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMNsmMMMMMMMMMMMMMMNNNNMMNNNMMNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNMMNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*/
import { readFileSync, writeFileSync, mkdir } from 'fs';
import { Whatsapp } from '../api/whatsapp';
import { CreateConfig, defaultOptions } from '../config/create-config';
import {
  isAuthenticated,
  isInsideChat,
  asciiQr,
  retrieveQR,
  SessionTokenCkeck,
} from './auth';
import { initWhatsapp, injectApi, initBrowser } from './browser';
import * as Spinnies from 'spinnies';
import path = require('path');
import {
  scrapeImg,
  scrapeLogin,
  scrapeDesconnected,
  scrapeDeleteToken,
  deleteFiles,
} from '../api/helpers';
import { checkUpdates, welcomeScreen } from './welcome';
import { ScrapQrcode } from '../api/model/qrcode';

/**
 * Start the bot
 * @param session, You must pass a string type parameter, this parameter will be the name of the client's session. If the parameter is not passed, the section name will be "session".
 * @param catchQR, A callback will be received, informing the status of the qrcode
 * @param statusFind, A callback will be received, informing the customer's status
 * @param options, Pass an object with the bot settings
 * @param browserSessionToken, Pass the session token information you can receive this token with the await client.getSessionTokenBrowser () function
 * @returns Whatsapp page, with this parameter you will be able to access the bot functions
 */

export async function create(
  session = 'session',
  catchQR?: (
    qrCode: string,
    asciiQR: string,
    attempt: number,
    urlCode?: string
  ) => void,
  statusFind?: (statusGet: string, session: string) => void,
  options?: CreateConfig,
  browserSessionToken?: object
): Promise<Whatsapp> {
  var _fail: any,
    browser_check: any,
    closeBrowser: any,
    attempt = 0,
    browserToken: any,
    Session: string,
    clientCheck: any,
    Session = session,
    DelFileCheck = false;

  const spinnies = new Spinnies({
    disableSpins: options ? options.disableSpins : false,
  });

  const mergedOptions = { ...defaultOptions, ...options };

  if (!mergedOptions.disableWelcome) {
    welcomeScreen();
  }

  if (mergedOptions.updatesLog) {
    await checkUpdates(spinnies);
  }

  // Initialize whatsapp
  spinnies.add(`${Session}-auth`, {
    text: 'Waiting...',
  });

  var browser = await initBrowser(Session, mergedOptions);

  if (browser === 'connect') {
    spinnies.fail(`${Session}-auth`, {
      text: `Error when try to connect ${mergedOptions.browserWS}`,
    });
    browser = null;
    throw `Error when try to connect ${mergedOptions.browserWS}`;
  }

  if (browser === 'launch') {
    spinnies.fail(`${Session}-auth`, {
      text: `Error no open browser`,
    });
    browser = null;
    throw `Error no open browser`;
  }

  if (browser !== null) {
    spinnies.add(`browser`, {
      text: 'check headless',
    });

    if (mergedOptions.headless) {
      spinnies.succeed(`browser`, {
        text: 'headless option is active, browser hidden',
      });
    } else {
      spinnies.succeed(`browser`, {
        text: 'headless option is disabled, browser visible',
      });
    }

    if (!mergedOptions.browserWS) {
      browser['_process'].once('close', () => {
        browser['isClose'] = true;
      });
    }

    ///disconnect || close
    _fail = setInterval(() => {
      if (mergedOptions.browserWS) {
        if (browser.isConnected() === false) {
          spinnies.add(`${Session}-auths`, {
            text: '....',
          });

          spinnies.fail(`${Session}-auths`, {
            text: `The server is closed ${Session}`,
          });

          if (statusFind) {
            statusFind('serverClose', Session);
          }
          browser.close();
          clearTimeout(closeBrowser);
          clearInterval(browser_check);
          clearInterval(_fail);
        }
      }

      if (browser['isClose'] != undefined && !mergedOptions.browserWS) {
        spinnies.add(`${Session}-auths`, {
          text: '....',
        });
        spinnies.fail(`${Session}-auths`, {
          text: 'The browser is closed',
        });
        if (statusFind) {
          statusFind('browserClose', Session);
        }
        clearTimeout(closeBrowser);
        clearInterval(clientCheck);
        clearInterval(_fail);
      }
    }, 1000);

    if (SessionTokenCkeck(browserSessionToken)) {
      browserToken = browserSessionToken;
    }

    const waPage = await initWhatsapp(
      Session,
      mergedOptions,
      browser,
      browserToken
    );

    if (waPage) {
      spinnies.update(`${Session}-auth`, { text: 'Authenticating...' });
      let authenticated = null;
      clientCheck = setInterval(async () => {
        ////check delete file
        var DeleteToken = await scrapeDeleteToken(waPage).catch(() => {});
        if (!DelFileCheck && DeleteToken === true) {
          deleteFiles(mergedOptions, Session, spinnies);
          if (statusFind) {
            statusFind('deleteToken', Session);
          }
          DelFileCheck = true;
        }
        ///client disconnect mobile
        var clientInput = await scrapeLogin(waPage).catch(() => {}),
          clientExit = await scrapeDesconnected(waPage).catch(() => {});
        if (clientInput === true || clientExit === true) {
          spinnies.add(`${Session}-authS`, { text: '...' });
          spinnies.fail(`${Session}-authS`, {
            text: 'client has desconnected in to mobile',
          });
          if (statusFind) {
            statusFind('desconnectedMobile', Session);
          }
          deleteFiles(mergedOptions, Session, spinnies);
          browser.close();
          browser.disconnect();
          clearInterval(_fail);
          clearInterval(browser_check);
          clearTimeout(closeBrowser);
          clearInterval(clientCheck);
        }
      }, 1000);

      //session authenticated
      await isAuthenticated(waPage)
        .then((e) => {
          authenticated = e;
        })
        .catch(() => {});

      if (authenticated != null) {
        // If not authenticated, show QR and wait for scan
        if (authenticated) {
          // Wait til inside chat
          if (statusFind) {
            statusFind('isLogged', Session);
          }

          await isInsideChat(waPage).toPromise();
          spinnies.succeed(`${Session}-auth`, { text: 'Authenticated' });
        } else {
          if (statusFind) {
            statusFind('notLogged', Session);
          }
          spinnies.add(`autoclose`, { text: 'check autoClose' });

          if (mergedOptions.autoClose > 0) {
            spinnies.succeed(`autoclose`, {
              text: 'the autoClose function is on',
            });
            ////on autoclose
            closeBrowser = setTimeout(() => {
              browser.disconnect();
              browser.close();
              if (statusFind) {
                statusFind('autocloseCalled', Session);
              }
              spinnies.add(`${Session}-auths`, {
                text: `....`,
              });
              spinnies.fail(`${Session}-auths`, {
                text: `Session Autoclose Called`,
              });

              clearInterval(_fail);
              clearInterval(browser_check);
              clearTimeout(closeBrowser);
              clearInterval(clientCheck);
            }, mergedOptions.autoClose);
          } else {
            spinnies.succeed(`autoclose`, {
              text: 'the autoClose function is off ',
            });
          }

          let urlCode = null;

          ///scraper qrcode
          browser_check = setInterval(async () => {
            ///close client browser
            if (
              browser['isClose'] != undefined ||
              browser.isConnected() === false
            ) {
              if (statusFind) {
                statusFind('qrReadFail', Session);
              }
              clearTimeout(closeBrowser);
              clearInterval(_fail);
              clearInterval(browser_check);
              clearInterval(clientCheck);
            } else {
              let qrResult: ScrapQrcode | undefined;

              qrResult = await scrapeImg(waPage).catch(() => undefined);
              if (!qrResult || !qrResult.urlCode) {
                qrResult = await retrieveQR(waPage).catch(() => undefined);
              }

              if (
                !qrResult ||
                !qrResult.urlCode ||
                qrResult.urlCode === urlCode
              ) {
                return;
              }

              urlCode = qrResult.urlCode;
              const qr = await asciiQr(urlCode);

              if (catchQR) {
                catchQR(qrResult.base64Image, qr, attempt++, urlCode);
              }
              if (mergedOptions.logQR) {
                spinnies.update(`${Session}-auth`, {
                  text: `Scan QR for Session: ${Session}\n${qr}`,
                });
              }
            }
          }, 1000);

          var IsLog = await isInsideChat(waPage).toPromise();
          if (IsLog == false) {
            spinnies.fail(`${Session}-auth`, {
              text: 'Not Login',
            });
            throw 'Error in login';
          }
          if (statusFind) {
            statusFind('qrReadSuccess', Session);
          }
          spinnies.succeed(`${Session}-auth`, {
            text: 'Compilation Mutation',
          });
        }

        clearInterval(browser_check);
        clearTimeout(closeBrowser);
        spinnies.add(`${Session}-inject`, { text: 'Injecting Sibionte...' });
        await injectApi(waPage);
        spinnies.succeed(`${Session}-inject`, {
          text: 'Starting With Success!',
        });

        // Saving Token
        spinnies.add(`${Session}-inject`, { text: 'Saving Token...' });

        if (true || (browserToken && !mergedOptions.createPathFileToken)) {
          const localStorage = JSON.parse(
            await waPage.evaluate(() => {
              return JSON.stringify(window.localStorage);
            })
          );

          let {
            WABrowserId,
            WASecretBundle,
            WAToken1,
            WAToken2,
          } = localStorage;

          try {
            setTimeout(() => {
              mkdir(
                path.join(
                  path.resolve(
                    process.cwd() + mergedOptions.mkdirFolderToken,
                    mergedOptions.folderNameToken
                  )
                ),
                { recursive: true },
                (err) => {
                  if (err) {
                    spinnies.fail(`${Session}-inject`, {
                      text: 'Failed to create folder tokens...',
                    });
                  }
                }
              );
            }, 200);

            setTimeout(() => {
              writeFileSync(
                path.join(
                  path.resolve(
                    process.cwd() + mergedOptions.mkdirFolderToken,
                    mergedOptions.folderNameToken
                  ),
                  `${Session}.data.json`
                ),
                JSON.stringify({
                  WABrowserId,
                  WASecretBundle,
                  WAToken1,
                  WAToken2,
                })
              );
              spinnies.succeed(`${Session}-inject`, {
                text: 'Token saved successfully...',
              });
            }, 500);
          } catch (error) {
            spinnies.fail(`${Session}-inject`, {
              text: 'Failed to save token...',
            });
          }
        }

        if (mergedOptions.debug) {
          const debugURL = `http://localhost:${readFileSync(
            `./${Session}/DevToolsActivePort`
          ).slice(0, -54)}`;
          console.log(`\nDebug: \x1b[34m${debugURL}\x1b[0m`);
        }

        return new Whatsapp(waPage);
      }
    }
  }
}
